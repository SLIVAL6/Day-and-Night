<html>

<head>
  <title>Computer Graphics Assessment 4</title>
</head>

<style>
  body {
    margin: 0;
  }

  canvas {
    width: 100%;
    height: 100%;
  }
</style>

<body>
  <link rel = "shortcut icon" href = "#">

  <style>
    body {
      font-family: Monospace;
      background-color: #000;
      color: #fff;
      margin: 0px;
      overflow: hidden;
    }

    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: left;
    }
  </style>

  <div id = "info">
    <p>
      Computer Graphics - Assessment 4<br>
      Natasha<br>
    </p>
  </div>

  <script type = "importmap">
			{
				"imports": {
					"three": "./build/three.module.js"
				}
			}
	</script>

  <script type = "module">

    import * as THREE from 'three';
    import { OrbitControls } from './build/OrbitControls.js';
    import { Perlin } from './build/perlin.js';
    import { OBJLoader } from './build/loaders/OBJLoader.js';
    import { MTLLoader } from './build/loaders/MTLLoader.js';
    import { GUI } from './build/lil-gui.module.min.js';
    import { Water } from './build/Water.js';
    import { Sky } from './build/Sky.js';
    import { Reflector } from './build/Reflector.js';

    // Create scene
    var scene = new THREE.Scene();
    var ratio = window.innerWidth / window.innerHeight;

    // Camera setup
    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
    var cameraTarget = {x:0, y:0, z:0};
    camera.position.y = 7;
    camera.position.z = 100;
    //camera.rotation.y = Math.PI / 2999;


    var cameralight = new THREE.PointLight( new THREE.Color(1,1,1), 1 );
 	  cameralight.name = 'Light';
    camera.add( cameralight );
 	  scene.add(camera);
    scene.background = new THREE.Color(0,0,0);

    // Renderer setup
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Clears the scene when parameters are updated
    function ClearScene() {
      for (let i = scene.children.length - 1; i >= 0; i--) {
        if (scene.children[i].type == "Mesh") {
          scene.remove(scene.children[i]);
        }
      }
    }

    function ClearTrees() {
      for (let i = scene.children.length - 1; i >= 0; i--) {
        if (scene.children[i].name == "tree") {
          scene.remove(scene.children[i]);
        }
      }
    }

    // variables
    var FrameMatrix = [];
    var subFrames = 10;
    var currFrame = 0;
    var vertices = [];
    var v2 = [];
    var positions = [];
    var treePositions = [];
    var lampPositions = [];
    var pinePositions = [];
    var rockPositions = [];
    var worldSize = 100;
    var lampNumber = 2;
    var treeNumber = 20;
    var pineNumber = 50;
    var grassNumber = 500;
    var rockNumber = 50;
    var trees = [];
    var waterHeight = -3.5;
    var faces = [];
    var reload = false;
    var def = 50;
    var w = 100;
    var watercheck = true;


    
    


    //Creates the terrain Plane
    var planeGeometry = new THREE.BoxGeometry(worldSize, worldSize, 256, 256);
    var planeMaterial = new THREE.MeshBasicMaterial();
    planeMaterial.vertexColors = THREE.VertexColors;
    planeMaterial.color = new THREE.Color(0.694, 1, 0.431);
    planeMaterial.side = THREE.DoubleSide;
    var terrain = new THREE.Mesh(planeGeometry,planeMaterial);
    scene.add(terrain);

    //Adds noise to terrain
    var perlin = new Perlin();
    var peak = 12;
    var smoothing = 100;
    var max = 0;
    var lowest = 0;
    vertices = terrain.geometry.attributes.position.array;
    for (var i = 0; i <= vertices.length; i += 3) {
        vertices[i+2] = peak * perlin.noise(
            vertices[i]/smoothing, 
            vertices[i+1]/smoothing
        );
        if (vertices[i+2]/smoothing > max){
          max = vertices[i+2]/smoothing;
        }
        if (vertices[i+2]/smoothing < lowest) {
          lowest = vertices[i+2]/smoothing;
        }
    }

    terrain.geometry.attributes.position.needsUpdate = true;
    terrain.geometry.computeVertexNormals();
    terrain.geometry.rotateX(Math.PI/2);

    console.log("max: " + max);
    console.log("lowest: " + lowest);

    
    var dif = max-lowest-1;
    waterHeight = dif-2;
    if (dif < 15) {
      //watercheck = false;
    }
    console.log(waterHeight);


    
    /*
    //ray testing
    var places = [];

    for (var i = -worldSize/2; i < worldSize/2; i=i+1) {
      for (var j = -worldSize/2; j < worldSize/2; i=i+1) {
        let raycaster = new THREE.Raycaster();
        let rayPos = new THREE.Vector3(i,500,j);
        let rayDir = new THREE.Vector3(0, -1, 0);
        let ray = new THREE.Ray(rayPos, rayDir);
        raycaster.ray = ray;
        let intersect = raycaster.intersectObject(terrain);
        //var pos = intersect[0].point;
        places.push(intersect.point);
        //places.push(intersect[0].point.x, intersect[0].point.y, intersect[0].point.z);
      }
    }
    console.log(places);*/

    var vertices2;
    var water;
    function buildWater() {
      /*var waterGeometry = new THREE.PlaneGeometry(worldSize, worldSize, 256, 256);
      var waterMaterial = new THREE.MeshLambertMaterial();
      waterMaterial.color = new THREE.Color(0, 0.843, 1);
      waterMaterial.side = THREE.DoubleSide;
      waterMaterial.transparent = true;
      waterMaterial.opacity = 0.2;
      waterMaterial.reflectivity = 100;
      water = new THREE.Mesh(waterGeometry,waterMaterial);
      scene.add(water);
      water.geometry.attributes.position.needsUpdate = true;
      water.geometry.computeVertexNormals();
      water.position.y = waterHeight+0.01;
      water.geometry.rotateX(-Math.PI/2);*/

      var waterMirrorGeometry = new THREE.PlaneGeometry(worldSize, worldSize, 256, 256);
      var waterMirror = new Reflector( waterMirrorGeometry, {
        clipBias: 0.003,
        textureWidth: window.innerWidth * window.devicePixelRatio,
        textureHeight: window.innerHeight * window.devicePixelRatio,
        //color: 0x5c8ead
      } );
      waterMirror.position.y = waterHeight;
      waterMirror.rotateX(-Math.PI/2);
      scene.add(waterMirror);

      /*
      var perlin2 = new Perlin();
      var peak2 = 0.01;
      var smoothing2 = 10;
      vertices2 = water.geometry.attributes.position.array;
      for (var i = 0; i <= vertices2.length; i += 3) {
          vertices2[i+2] = peak2 * perlin2.noise(
              vertices2[i]/smoothing2, 
              vertices2[i+1]/smoothing2
          );
      }*/

      
    }

    function animateWater(){
      water.geometry.attributes.position.needsUpdate = true;
      water.geometry.computeVertexNormals();
      //water.geometry.rotateX(0);
      //water.geometry.rotateX(Math.PI/2);
      var temp;
      if (ti)
      for (var i = 0; i < vertices2.length; i++) {
        if (i == 0) {temp = vertices2[i]}
        if (i+1 != vertices2.length) {
          vertices2[i] = vertices2[i+1];
        }
        else {
          vertices2[i+1] = temp;
        } 
      }
      water.geometry.attributes.position.needsUpdate = true;
      water.geometry.computeVertexNormals();
      //water.geometry.rotateX(Math.PI/2);
      
      requestAnimationFrame(animateWater);
      renderer.render(scene, camera);
    }

    //animateWater();


    //LOAD LAMPS
    function spawnLamps() {
      var mtlloader=new MTLLoader();
      mtlloader.setPath( '../models/' )
      mtlloader.load( 'streetLamp.mtl', function ( materials ) 
      {
        materials.preload();
        var objload=new OBJLoader();
        objload.setMaterials( materials )
        objload.setPath( '../models/' )
        objload.load( 'streetLamp.obj', function ( object ) 
        {
          var box3 = new THREE.Box3();
          box3.setFromObject (object);
          var CenterBB= new THREE.Vector3();
          var SizeBB = new THREE.Vector3();
          box3.getCenter(CenterBB);
          box3.getSize(SizeBB);
          for ( var i = 0, l = object.children.length; i < l; i ++ ) 
          {
            object.children[i].material.color= new THREE.Color(1,1,1);
          }

          object.castShadow = true;
          object.receiveShadow = true;

          //SPAWNING IN
          for (var i = 0; i < lampNumber; i++) {
            var clone = object.clone();
            var raycaster = new THREE.Raycaster();
            var posx = THREE.MathUtils.randInt(-worldSize/2,worldSize/2);
            var posz = THREE.MathUtils.randInt(-worldSize/2,worldSize/2);
            var rayPos = new THREE.Vector3(posx,1000,posz);
            var rayDir = new THREE.Vector3(0, -1, 0);
            var ray = new THREE.Ray(rayPos, rayDir);
            raycaster.ray = ray;
            let intersect = raycaster.intersectObject(terrain);
            var pos = intersect[0].point;
            //CHECKING IS POSITION IS TAKEN
            var isIn = false;
            for (var i = 0; i < positions.length; i++) {
              if (positions[i].x == pos.x && positions[i].y == pos.y && positions[i].z == pos.z) {
                isIn = true;
              }
            }
            //CHECKING IF PLACE IS AT THE RIGHT HEIGHT
            if (intersect[0].point.y > waterHeight && isIn == false) {
              positions.push(pos)
              //console.log(pos);
              clone.scale.set(1,1,1);
              clone.position.set(intersect[0].point.x,intersect[0].point.y,intersect[0].point.z);
              //trees.push(object);
              scene.add(clone);
            }
            //IF PLACE IS NOT AT RIGHT HEIGHT, TRYING AGAIN
            else {
              i = i - 1;
            } 
          }
        });
      } );
    }
    
    //LOAD TREES
    function spawnTrees() {
      var treeModel;
      var treeMaterial1;
      var bodyMaterial;
      var mtlload = new MTLLoader();
      mtlload.setPath('../models/')
      mtlload.load('Oak_Tree.mtl', function(materials) 
      {
        materials.preload();
        var objload = new OBJLoader();
        objload.setMaterials(materials)
        objload.setPath('../models/')
        objload.load('Oak_Tree.obj', function(object) 
        {
          var box3 = new THREE.Box3();
          box3.setFromObject(object);
          var CenterBB = new THREE.Vector3();
          var SizeBB = new THREE.Vector3();
          box3.getCenter(CenterBB);
          box3.getSize(SizeBB);

          // Change colour
          /*
          bodyMaterial = materials.materials.Body;
          var red = Math.random();
          var green = Math.random();
          var blue = Math.random();
          changeColor(bodyMaterial, new THREE.Color(red, green, blue));*/

          for(var i = 0, l = object.children.length; i < l; i ++) 
          {
            object.children[i].material.color = new THREE.Color(1,1,1);
          }

          object.castShadow = true;
          object.receiveShadow = true;

          //SPAWNING IN
          for (var i = 0; i < treeNumber; i++) {
            var clone = object.clone();
            var rot = THREE.MathUtils.randFloat(-1,1);
            var raycaster = new THREE.Raycaster();
            var posx = THREE.MathUtils.randInt((-worldSize/2)+2,(worldSize/2)-2);
            var posz = THREE.MathUtils.randInt((-worldSize/2)+2,(worldSize/2)-2);
            var rayPos = new THREE.Vector3(posx,1000,posz);
            var rayDir = new THREE.Vector3(0, -1, 0);
            var ray = new THREE.Ray(rayPos, rayDir);
            raycaster.ray = ray;
            let intersect = raycaster.intersectObject(terrain);

            //CHECKING IF PLACE IS TAKEN
            var pos = intersect[0].point;
            var isIn = false;
            for (var i = 0; i < positions.length; i++) {
              if (positions[i].x == pos.x && positions[i].y == pos.y && positions[i].z == pos.z) {
                isIn = true;
              }
            }

            //CHECKING IF PLACE IS AT THE RIGHT HEIGHT
            if (intersect[0].point.y > waterHeight && isIn == false ){//&& intersect[0].point.y < waterHeight+5) {
              
              treePositions.push(pos);
              positions.push(pos);
              //console.log(pos);
              clone.scale.set(2,2,2);
              clone.position.set(intersect[0].point.x,intersect[0].point.y,intersect[0].point.z);
              clone.rotateY(rot);
              clone.name = "tree";
              
              scene.add(clone);
              trees.push(clone);
            }
            //OTHERWISE TRYING AGAIN
            else {
              i = i - 1;
            } 
          }
        });
      });
    }

    //LOAD PINE TREES
    function spawnPines() {
      var mtlload = new MTLLoader();
      mtlload.setPath('../models/')
      mtlload.load('Fir_Tree.mtl', function(materials) 
      {
        materials.preload();
        var objload = new OBJLoader();
        objload.setMaterials(materials)
        objload.setPath('../models/')
        objload.load('Fir_Tree.obj', function(object) 
        {
          var box3 = new THREE.Box3();
          box3.setFromObject(object);
          var CenterBB = new THREE.Vector3();
          var SizeBB = new THREE.Vector3();
          box3.getCenter(CenterBB);
          box3.getSize(SizeBB);

          for(var i = 0, l = object.children.length; i < l; i ++) 
          {
            object.children[i].material.color = new THREE.Color(1,1,1);
          }

          object.castShadow = true;
          object.receiveShadow = true;

          //SPAWNING IN
          for (var i = 0; i < pineNumber; i++) {
            var clone = object.clone();
            var rot = THREE.MathUtils.randFloat(-1,1);
            var raycaster = new THREE.Raycaster();
            var posx = THREE.MathUtils.randInt((-worldSize/2)+2,(worldSize/2)-2);
            var posz = THREE.MathUtils.randInt((-worldSize/2)+2,(worldSize/2)-2);
            var rayPos = new THREE.Vector3(posx,1000,posz);
            var rayDir = new THREE.Vector3(0, -1, 0);
            var ray = new THREE.Ray(rayPos, rayDir);
            raycaster.ray = ray;
            let intersect = raycaster.intersectObject(terrain);

            //CHECKING IF PLACE IS TAKEN
            var pos = intersect[0].point;
            var isIn = false;
            for (var i = 0; i < pinePositions.length; i++) {
              if (pinePositions[i].x == pos.x && pinePositions[i].y == pos.y && pinePositions[i].z == pos.z) {
                isIn = true;
              }
            }

            //CHECKING IF PLACE IS AT THE RIGHT HEIGHT
            if (intersect[0].point.y >= waterHeight && isIn == false) {
              pinePositions.push(pos);
              positions.push(pos);
              //console.log(pos);
              clone.scale.set(2,2,2);
              clone.position.set(intersect[0].point.x,intersect[0].point.y,intersect[0].point.z);
              clone.rotateY(rot);
              trees.push(clone);
              scene.add(clone);
            }
            //OTHERWISE TRYING AGAIN
            else {
              i = i - 1;
            } 
          }
        });
      });
    }

    function spawnGrass() {
      var mtlload = new MTLLoader();
      mtlload.setPath('../models/')
      mtlload.load('grass_low_poly.mtl', function(materials) 
      {
        materials.preload();
        var objload = new OBJLoader();
        objload.setMaterials(materials)
        objload.setPath('../models/')
        objload.load('grass_low_poly.obj', function(object) 
        {
          var box3 = new THREE.Box3();
          box3.setFromObject(object);
          var CenterBB = new THREE.Vector3();
          var SizeBB = new THREE.Vector3();
          box3.getCenter(CenterBB);
          box3.getSize(SizeBB);

          for(var i = 0, l = object.children.length; i < l; i ++) 
          {
            object.children[i].material.color = new THREE.Color(1,1,1);
          }

          object.castShadow = true;
          object.receiveShadow = true;

          //SPAWNING IN
          for (var i = 0; i < grassNumber; i++) {
            var clone = object.clone();
            var rot = THREE.MathUtils.randFloat(-1,1);
            var raycaster = new THREE.Raycaster();
            var posx = THREE.MathUtils.randInt((-worldSize/2)+2,(worldSize/2)-2);
            var posz = THREE.MathUtils.randInt((-worldSize/2)+2,(worldSize/2)-2);
            var rayPos = new THREE.Vector3(posx,1000,posz);
            var rayDir = new THREE.Vector3(0, -1, 0);
            var ray = new THREE.Ray(rayPos, rayDir);
            raycaster.ray = ray;
            let intersect = raycaster.intersectObject(terrain);

            //CHECKING IF PLACE IS TAKEN
            var pos = intersect[0].point;
            var isIn = false;
            for (var i = 0; i < positions.length; i++) {
              if (positions[i].x == pos.x && positions[i].y == pos.y && positions[i].z == pos.z) {
                isIn = true;
              }
            }

            //CHECKING IF PLACE IS AT THE RIGHT HEIGHT
            if (intersect[0].point.y > waterHeight && isIn == false) {
              
              positions.push(pos);
              //console.log(pos);
              clone.scale.set(0.1,0.1,0.1);
              clone.position.set(intersect[0].point.x,intersect[0].point.y,intersect[0].point.z);
              clone.rotateY(rot);
              trees.push(clone);
              scene.add(clone);
              console.log("grass");
            }
            //OTHERWISE TRYING AGAIN
            else {
              i = i - 1;
            } 
          }
        });
      });
    }

    function spawnRocks() {
      var mtlload = new MTLLoader();
      mtlload.setPath('../models/')
      mtlload.load('Rocks.mtl', function(materials) 
      {
        materials.preload();
        var objload = new OBJLoader();
        objload.setMaterials(materials)
        objload.setPath('../models/')
        objload.load('Rock1.obj', function(object) 
        {
          var box3 = new THREE.Box3();
          box3.setFromObject(object);
          var CenterBB = new THREE.Vector3();
          var SizeBB = new THREE.Vector3();
          box3.getCenter(CenterBB);
          box3.getSize(SizeBB);

          for(var i = 0, l = object.children.length; i < l; i ++) 
          {
            object.children[i].material.color = new THREE.Color(1,1,1);
          }

          object.castShadow = true;
          object.receiveShadow = true;

          //SPAWNING IN
          rockNumber = 50;
          for (var i = 0; i < rockNumber; i++) {
            var clone = object.clone();
            var rot = THREE.MathUtils.randFloat(-1,1);
            var raycaster = new THREE.Raycaster();
            var posx = THREE.MathUtils.randInt((-worldSize/2)+2,(worldSize/2)-2);
            var posz = THREE.MathUtils.randInt((-worldSize/2)+2,(worldSize/2)-2);
            var rayPos = new THREE.Vector3(posx,1000,posz);
            var rayDir = new THREE.Vector3(0, -1, 0);
            var ray = new THREE.Ray(rayPos, rayDir);
            raycaster.ray = ray;
            let intersect = raycaster.intersectObject(terrain);

            var pos = intersect[0].point;
            //CHECKING IF PLACE IS TAKEN
            /*
            var isIn = false;
            for (var i = 0; i < positions.length; i++) {
              if (positions[i].x == pos.x && positions[i].y == pos.y && positions[i].z == pos.z) {
                isIn = true;
              }
            }*/

            //CHECKING IF PLACE IS AT THE RIGHT HEIGHT
            if (intersect[0].point.y > waterHeight ){//&& isIn == false) {
              
              positions.push(pos);
              //console.log(pos);
              clone.scale.set(5,5,5);
              clone.position.set(intersect[0].point.x,intersect[0].point.y-0.2,intersect[0].point.z);
              //clone.rotateY(rot);
              trees.push(clone);
              scene.add(clone);
              console.log("rock");
            }
            //OTHERWISE TRYING AGAIN
            else {
              i = i - 1;
            } 
          }
        });
      });
    }
    

    //spawning things called
    if (watercheck = true) {
      buildWater();
    }
    
    spawnLamps();
    spawnTrees();
    spawnPines();
    spawnRocks();
    spawnGrass();
    

    console.log(lampPositions);
    console.log(treePositions);
    console.log(pinePositions);
    console.log(waterHeight);



    //GUI
    const gui = new GUI(),

    folderWorldGeneration = gui.addFolder('WorldGeneration'),
      wgParams = {
        // choose world size
        get 'World Size'() {
          return worldSize;
        },
        set 'World Size'(v) {
          worldSize = v;
        },

        // Set number of normal trees
        get 'Number of Trees'() {
          return treeNumber;
        },
        set 'Number of Trees'(v) {
          treeNumber = v;
        },

        // Set number of lamps
        get 'Number of Lamps'() {
          return lampNumber;
        },
        set 'Number of Lamps'(v) {
          lampNumber = v;
        },

        // Set number of rocks
        get 'Number of Rocks'() {
          return rockNumber;
        },
        set 'Number of Rocks'(v) {
          rockNumber = v;
        }
      };
    folderWorldGeneration.add(wgParams, 'World Size', 50, 100);
    folderWorldGeneration.add(wgParams, 'Number of Trees', 0, 100).listen().onChange();
    folderWorldGeneration.add(wgParams, 'Number of Lamps', 0, 10).listen().onChange();
    folderWorldGeneration.add(wgParams, 'Number of Rocks', 0, 50).listen().onChange();

    
    var controls = new OrbitControls(camera, renderer.domElement);

    var defwsize = worldSize;
    var deflamps = lampNumber;
    var deftrees = treeNumber;
    var defpines = pineNumber;
    var defrocks = rockNumber;
    // Final update loop
    var MyUpdateLoop = function () {
      renderer.render(scene, camera);

      if (worldSize != defwsize) {
        
      }


      controls.update();
      requestAnimationFrame(MyUpdateLoop);
    };

    requestAnimationFrame(MyUpdateLoop);

    function handleKeyDown(event) {
    }

    window.addEventListener('keydown', handleKeyDown, false);

    // Called when the window is resized
    var MyResize = function () {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    };

    // Link the resize of the window to the camera update
    window.addEventListener('resize', MyResize);
  </script>
</body>

</html>