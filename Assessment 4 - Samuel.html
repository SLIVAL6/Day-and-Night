<html>

<head>
  <title>Computer Graphics Assessment 4</title>
</head>

<style>
  body {
    margin: 0;
  }

  canvas {
    width: 100%;
    height: 100%;
  }
</style>

<body>
  <link rel = "shortcut icon" href = "#">

  <style>
    body {
      font-family: Monospace;
      background-color: #000;
      color: #fff;
      margin: 0px;
      overflow: hidden;
    }

    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: left;
    }
  </style>

  <div id = "info">
    <p>
      Computer Graphics - Assessment 4<br>
      Samuel<br>
    </p>
  </div>

  <script type="x-shader/x-vertex" id="vertexshader">

    varying vec2 vUv;

    void main() {

      vUv = uv;

      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  </script>

  <script type="x-shader/x-fragment" id="fragmentshader">

    uniform sampler2D baseTexture;
    uniform sampler2D bloomTexture;

    varying vec2 vUv;

    void main() {

      gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

    }
  </script>

  <script type = "importmap">
			{
				"imports": {
					"three": "./build/three.module.js"
				}
			}
	</script>

  <script type = "module">

    import * as THREE from 'three';
    import { OrbitControls } from './build/OrbitControls.js';
    import { GUI } from './build/lil-gui.module.min.js';
    import { EffectComposer } from './build/EffectComposer.js';
    import { RenderPass } from './build/RenderPass.js';
    import { ShaderPass } from './build/ShaderPass.js';
    import { UnrealBloomPass } from './build/UnrealBloomPass.js';
    import { Lensflare, LensflareElement } from './build/Lensflare.js';

    // Create scene
    var scene = new THREE.Scene();
    scene.fog = new THREE.Fog(scene.background, 3500, 15000);
    var ratio = window.innerWidth / window.innerHeight;

    // Camera setup
    var camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 1000);
    camera.position.set(0, 5, 15);
    camera.lookAt(0, 0, 1);

    // Renderer setup
    var renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // Render Pass
    const renderScene = new RenderPass (scene, camera);

    // Bloom layer and bloom values
    const layers = 3;
    const params = {
      exposure: 1,
      bloomStrength: 10,
      bloomThreshold: 0,
      bloomRadius: 0
    };

    // Bloom pass
    const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
		bloomPass.threshold = params.bloomThreshold;
		bloomPass.strength = params.bloomStrength;
		bloomPass.radius = params.bloomRadius;

    // Effect composer for bloom
    const bloomComposer = new EffectComposer( renderer );
		bloomComposer.renderToScreen = false;
		bloomComposer.addPass( renderScene );
		bloomComposer.addPass( bloomPass );

    // Final shader pass
    const finalPass = new ShaderPass(
		  new THREE.ShaderMaterial( {
			  uniforms: {
				  baseTexture: { value: null },
				  bloomTexture: { value: bloomComposer.renderTarget2.texture }
				},
				vertexShader: document.getElementById('vertexshader').textContent,
				fragmentShader: document.getElementById('fragmentshader').textContent,
				defines: {}
			} ), 'baseTexture'
		);
		finalPass.needsSwap = true;

    // Final effect composer
		const finalComposer = new EffectComposer(renderer);
		finalComposer.addPass(renderScene);
		finalComposer.addPass(finalPass);

    // Ambient light
    const ambientLight = new THREE.AmbientLight(0x404040);
    ambientLight.intensity = 1;

    // Directional light from the sun
    const sunLight = new THREE.DirectionalLight( { color: 'white' } );
    sunLight.intensity = 1
    sunLight.castShadow = true;
    sunLight.position.x = 40;
    sunLight.position.y = 0;
    sunLight.position.z = 0;

    // Material used for bloom processing
    const darkMaterial = new THREE.MeshBasicMaterial( { color: 'black' } );

    // Lens flares
    const textureLoader = new THREE.TextureLoader();
    const textureFlare0 = textureLoader.load('./textures/lensflare0.png');
    const textureFlare3 = textureLoader.load('./textures/lensflare3.png');

    const lensflare = new Lensflare();
    function CreateLensflare()
    {
      lensflare.addElement( new LensflareElement( textureFlare0, 700, 0, sunMaterial.color ) );
      lensflare.addElement( new LensflareElement( textureFlare3, 60, 0.6 ) );
      lensflare.addElement( new LensflareElement( textureFlare3, 70, 0.7 ) );
      lensflare.addElement( new LensflareElement( textureFlare3, 120, 0.9 ) );
      lensflare.addElement( new LensflareElement( textureFlare3, 70, 1 ) );
    }

    // Moon texture
    const textureMoon = textureLoader.load('./textures/moon.png');

    // Clears the scene when parameters are updated
    function ClearScene() {
      for (let i = scene.children.length - 1; i >= 0; i--) {
        if (scene.children[i].type == "Mesh") {
          scene.remove(scene.children[i]);
        }
      }
    }

    // Frame information
    var FrameMatrix = [];
    var subFrames = 10;
    var currFrame = 0;

    // Creates Scene
    var point;
    var cube; // testing
    function CreateScene() {
      // Createss objects
      CreateSun();
      CreateMoon();
      CreateLensflare();
      
      // Attaches the sun and moon to world point (0, 0, 0)
      point = new THREE.Group();
      point.add(sun);
      point.add(moon);
      point.add(sunLight);
      scene.add(point);
      point.rotation.z = Math.PI;

      sunLight.add(lensflare);
      sunLight.lookAt = point;

      // Adds a plane
      CreatePlane();
      scene.add(plane);

      // Adds lighting
      scene.add(ambientLight);

      // Adds cube for light testing
      cube = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), darkMaterial);
      cube.position.x = 0;
      cube.position.y = 10;
      cube.position.z = 0;
      cube.castShadow = true;
      cube.receiveShadow = true;
      scene.add(cube);
    }

    CreateScene();

    var sun;
    var sunMaterial;
    function CreateSun() {
      // Material for the Sun
      sunMaterial = new THREE.MeshLambertMaterial();
      sunMaterial.color.setHSL(0.152, 0.95, 0.57);
      sunMaterial.wireframe = false;

      // Sphere geometry for the Sun
      var sunGeometry = new THREE.SphereGeometry(2, 15, 15);
        
      // Generates Sun with material and geometry
      sun = new THREE.Mesh(sunGeometry, sunMaterial);

      // Shadow properties
      sun.castShadow = false;
      sun.receiveShadow = false;

      // Sets position for the Sun
      sun.position.x = 40;
      sun.position.y = 0;
      sun.position.z = 0;

      // Sets rotation for the Sun
      sun.rotation.x = 0;
      sun.rotation.y = 0;
      sun.rotation.z = 0;
    }

    var moon;
    var moonMaterial;
    function CreateMoon() {
      // Material for the Moon
      moonMaterial = new THREE.MeshLambertMaterial();
      moonMaterial.color.setHSL(0, 0, 0.8);
      moonMaterial.wireframe = false;
      moonMaterial.map = textureMoon;

      // Sphere geometry for the Moon
      var moonGeometry = new THREE.SphereGeometry(2, 15, 15);
        
      // Generates Moon with material and geometry
      moon = new THREE.Mesh(moonGeometry, moonMaterial);

      // Shadow properties
      moon.castShadow = false;
      moon.receiveShadow = false;

      // Sets position for the Moon
      moon.position.x = -40;
      moon.position.y = 0;
      moon.position.z = 0;

      // Sets rotation for the Moon
      moon.rotation.x = 0;
      moon.rotation.y = 0;
      moon.rotation.z = 0;
    }

    var plane;
    var planeMaterial;
    function CreatePlane() {
      // Material for the plane
      planeMaterial = new THREE.MeshLambertMaterial();
      planeMaterial.color.setHSL(0, 0, 0.8);
      planeMaterial.wireframe = false;

      // Plane geometry
      var planeGeometry = new THREE.PlaneGeometry(50, 50, 50, 50);

      // Generates plane
      plane = new THREE.Mesh(planeGeometry, planeMaterial);

      // Shadow properties
      plane.castShadow = false;
      plane.receiveShadow = true;

      // Sets position for the plane
      plane.position.x = 0;
      plane.position.y = 0;
      plane.position.z = 0;

      // Sets rotation for the plane
      plane.rotation.x = - Math.PI / 2;
      plane.rotation.y = 0;
      plane.rotation.z = 0;
    }

    const maxTime = 1440; // Amount of minutes in a day (24 hrs * 60 mins)
    var time = 1440; // Value between 0 and 1440 in minutes
    var currentTime; // Value between 0 and 1 to represent current time of day
    var timePaused = false; // Pauses time
    var minutes = 1; // Rate at which time passes; set to negative to reverse time
    function ProcessTime() {
      // Adds minutes to time each update frame
      if(!timePaused)
      {
        time += minutes;
      }
      
      // Resets time to 0 when it exceeds 1440
      if(time >= maxTime)
      {
        time = 0;
      }

      // Sets current time
      currentTime = time / maxTime;
    }

    // Directly sets the value of time
    function SetTime(newTime) {
      time = newTime;
    }

    // Rotation of the Sun and Moon around world point (0, 0, 0)
    function SunMoonRotation() {
      point.rotation.z = Math.PI * 2 * currentTime;
    }

    var moonPhase; // Value between 0 and 1 to rotate the moon
    var moonPaused = false; // Locks moon rotation
    // Rotation of the moon to simulate moon phases
    function MoonPhases() {
      if(moonPaused)
      {
        return;
      }
      moon.rotation.y = Math.PI * 2 * currentTime;
    }

    // Controls
    var controls = new OrbitControls(camera, renderer.domElement);

    // GUI
    const gui = new GUI(),

      // Parameters for time
      folderTime = gui.addFolder('Time'),
      timeParams = {
        // Pause time
        get 'Paused'() {
          return timePaused;
        },
        set 'Paused'(v) {
          timePaused = v;
        },

        // Set current time (in minutes)
        get 'Time'() {
          return time;
        },
        set 'Time'(v) {
          time = v;
        },

        // Change speed of time
        get 'Speed'() {
          return minutes;
        },
        set 'Speed'(v) {
          minutes = v;
        }
      },

      // Parameters for bloom
      folderBloom = gui.addFolder('Bloom'),
      bloomParams = {
        // Exposure
        get 'Exposure'() {
          return renderer.toneMappingExposure;
        },
        set 'Exposure'(v) {
          renderer.toneMappingExposure = v;
        },

        // Bloom strength
        get 'Bloom Strength'() {
          return bloomPass.strength;
        },
        set 'Bloom Strength'(v) {
          bloomPass.strength = Number(v);
        },

        // Bloom threshold
        get 'Bloom Threshold'() {
          return bloomPass.threshold;
        },
        set 'Bloom Threshold'(v) {
          bloomPass.threshold = Number(v);
        },

        // Bloom radius
        get 'Bloom Radius'() {
          return bloomPass.radius;
        },
        set 'Bloom Radius'(v) {
          bloomPass.radius = Number(v);
        }
      },

      // Parameters for moon phases
      folderMoon = gui.addFolder('Moon'),
      moonParams = {
        // Pause moon rotation
        get 'Pause Rotation'() {
          return moonPaused;
        },
        set 'Pause Rotation'(v) {
          moonPaused = v;
        }
      };
      
    folderTime.add(timeParams, 'Paused');
    folderTime.add(timeParams, 'Time', 0, 1440).listen().onChange();
    folderTime.add(timeParams, 'Speed', 0.1, 15);

    folderBloom.add(bloomParams, 'Exposure', 0, 16);
    folderBloom.add(bloomParams, 'Bloom Strength', 0, 20);
    folderBloom.add(bloomParams, 'Bloom Threshold', 0, 1);
    folderBloom.add(bloomParams, 'Bloom Radius', 0, 1);

    folderMoon.add(moonParams, 'Pause Rotation');

    // Update loop
    var MyUpdateLoop = function () {
      controls.update();

      // Rotates the Sun and Moon around the point at world position (0, 0, 0)
      ProcessTime();
      MoonPhases();
      SunMoonRotation();
      
      // Processes bloom
      plane.material = darkMaterial;
      cube.material = darkMaterial; // testing
      bloomComposer.render();
      plane.material = planeMaterial;
      sun.material = sunMaterial;
      moon.material = moonMaterial;
      cube.material = planeMaterial; // testing
      finalComposer.render();

      requestAnimationFrame(MyUpdateLoop);
    };

    requestAnimationFrame(MyUpdateLoop);

    function handleKeyDown(event) {
    }

    window.addEventListener('keydown', handleKeyDown, false);

    // Called when the window is resized
    var MyResize = function () {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    };

    // Link the resize of the window to the camera update
    window.addEventListener('resize', MyResize);
  </script>
</body>

</html>